/*
 *  RTIbuilder
 *  Copyright (C) 2008-11  Universidade do Minho and Cultural Heritage Imaging
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License version 3 as published
 *  by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package guicomponents;

import java.awt.image.BufferedImage;
import java.awt.*;
import java.util.ArrayList;
import java.util.Iterator;

/**Image panel used to draw areas inside the picture and select them, or for a more user friendly selection of some object in the image.
By default the area drawing is enabled, to switch of this option use the method {@link enableDraw(boolean drawArea)}*/
public class AreaSelectionPanel extends PreviewPanel {

    /**The mouse movement makes new selections*/
    protected final int FREE_SELECTION = 0;
    /**The mouse movement chages the current selected area from the left upper corner*/
    protected final int LU_CORNER = 1;
    /**The mouse movement chages the current selected area from the right upper corner*/
    protected final int RU_CORNER = 2;
    /**The mouse movement chages the current selected area from the left down corner*/
    protected final int LD_CORNER = 3;
    /**The mouse movement chages the current selected area from the right down  corner*/
    protected final int RD_CORNER = 4;
    /**The mouse movement moves the current selected area */
    protected final int MOVE = 5;
    /**Indicates if the user is making a new area or editing a made one*/
    protected int draw_mode = 0;
    /**Rectangles in each of the selected areas vertices for detecting the user intention of resizing*/
    protected Rectangle[] corners = {new Rectangle(), new Rectangle(), new Rectangle(), new Rectangle()};
    /**Selected areas in picture*/
    protected ArrayList<Rectangle> selectedAreas;
    /**Current selected area*/
    protected int current_area;
    /**The current selected area origin point, normally the area right upper corner*/
    public Point origin_point;
    /**The current selected area location*/
    protected Point loc_point;
    /**The current selected area end point, usually the right down corner*/
    public Point end_point;
    /**Point clicked by user*/
    protected Point click_point;
    /**Flags if drawing is enabled or not*/
    public boolean draw_new_areas;
    /**Flags a change to the panel*/
    protected boolean changed = false;

    /** Creates new form ImageSelectionPanel */
    public AreaSelectionPanel() {
        //initialize panel
        super();
        //initialize listeners
        initComponents();
        draw_new_areas = true;
        user_defined_scale = false;
        this.panel_image = null;
        selectedAreas = new ArrayList<Rectangle>();
        origin_point = new Point();
        end_point = new Point();
        loc_point = new Point();
    }

    /** Creates new form ImageSelectionPanel */
    public AreaSelectionPanel(BufferedImage bi) {
        //initialize panel
        super();
        //initialize listeners
        initComponents();
        user_defined_scale = false;
        draw_new_areas = true;
        this.panel_image = bi;
        selectedAreas = new ArrayList<Rectangle>();
        origin_point = new Point();
        end_point = new Point();
        loc_point = new Point();

    }

    public void cleanCropArea() {
        origin_point = new Point();
        end_point = new Point();
        loc_point = new Point();
        this.repaint();
    }

    /**Disables or enables the area drawing feature of the panel. If not the panel will only serve to chose a defined areas.
     * @param drawArea if true the user can draw new areas, false other wise.  
     */
    public void enableDraw(boolean drawArea) {
        draw_new_areas = drawArea;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
      // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
      private void initComponents() {

            setName("Form"); // NOI18N
            addMouseListener(new java.awt.event.MouseAdapter() {
                  public void mouseClicked(java.awt.event.MouseEvent evt) {
                        formMouseClicked(evt);
                  }
                  public void mousePressed(java.awt.event.MouseEvent evt) {
                        formMousePressed(evt);
                  }
                  public void mouseReleased(java.awt.event.MouseEvent evt) {
                        formMouseReleased(evt);
                  }
            });
            addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
                  public void mouseDragged(java.awt.event.MouseEvent evt) {
                        formMouseDragged(evt);
                  }
            });

      }// </editor-fold>//GEN-END:initComponents

    public void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged


        //On mouse drag with the left mouse button
        if (((evt.getModifiersEx() & java.awt.event.InputEvent.BUTTON1_DOWN_MASK) == java.awt.event.InputEvent.BUTTON1_DOWN_MASK) && draw_new_areas) {

            //Make sure that mouse position in the image
            int x = evt.getX(), y = evt.getY();
            x = (x < 0) ? 0 : x;
            y = (y < 0) ? 0 : y;
            x = (x > resized_width) ? resized_width : x;
            y = (y > resized_height) ? resized_height : y;

            //Work on real coordinates
            int real_x = (int) (x / resize_factor);
            int real_y = (int) (y / resize_factor);
            Point p = new Point(real_x, real_y);

            //If mouse on the upper left corner, change selected area size
            if (draw_mode == LU_CORNER) {
                Rectangle area = selectedAreas.get(current_area);
                //Get area end point
                int end_x = area.x + area.width;
                int end_y = area.y + area.height;
                //Where is the new left upper corner
                int min_x = Math.min(real_x, end_x),
                        min_y = Math.min(real_y, end_y);
                //Store the edited area
                selectedAreas.set(current_area, new Rectangle(min_x, min_y, end_x - min_x, end_y - min_y));
                changed = true;
                repaint();
            }

            //Mouse on the upper right corner
            if (draw_mode == RU_CORNER) {
                Rectangle area = selectedAreas.get(current_area);
                int end_y = area.y + area.height;
                //See where is the right upper corner
                int min_y = Math.min(real_y, end_y),
                        max_x = Math.max(area.x, real_x);
                selectedAreas.set(current_area, new Rectangle(area.x, min_y, max_x - area.x, end_y - min_y));
                changed = true;
                repaint();

            }
            //Mouse on the down left corner
            if (draw_mode == LD_CORNER) {
                Rectangle area = selectedAreas.get(current_area);
                int end_x = area.x + area.width;
                //See where is the left down corner
                int min_x = Math.min(real_x, end_x),
                        max_y = Math.max(area.y, real_y);

                selectedAreas.set(current_area, new Rectangle(min_x, area.y, end_x - min_x, max_y - area.y));
                changed = true;
                repaint();
            }
            //Mouse on the down right corner
            if (draw_mode == RD_CORNER) {
                Rectangle area = selectedAreas.get(current_area);
                //See where is the right down corner
                int max_x = Math.max(area.x, real_x),
                        max_y = Math.max(area.y, real_y);

                selectedAreas.set(current_area, new Rectangle(area.x, area.y, max_x - area.x, max_y - area.y));
                changed = true;
                repaint();
            }
            //Mouse on area
            if (draw_mode == MOVE) {
                Rectangle area = selectedAreas.get(current_area);
                //Where has the right corner in the beginnig
                int ori_x = (int) (loc_point.x);
                int ori_y = (int) (loc_point.y);

                //What has is deslocation
                int des_x = (int) ((real_x - ori_x));
                int des_y = (int) ((real_y - ori_y));
                loc_point = new Point(real_x, real_y);

                //Make sure the area is on image.
                int vertice_x = Math.min(Math.max(area.x + des_x, 0), panel_image.getWidth() - area.width);
                int vertice_y = Math.min(Math.max(area.y + des_y, 0), panel_image.getHeight() - area.height);

                selectedAreas.set(current_area, new Rectangle(vertice_x, vertice_y, area.width, area.height));
                changed = true;
                repaint();

            }

            //Mouse out of a area.
            if (draw_mode == FREE_SELECTION) {
                end_point = new Point((int) (x / resize_factor), (int) (y / resize_factor));
            }
            repaint();
        }
    }//GEN-LAST:event_formMouseDragged

public void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed

    //Detect in picture where the left mouse button as been pressed
    if (evt.getButton() == java.awt.event.MouseEvent.BUTTON1 && draw_new_areas) {
        //Get mouse location and make sure it is on image.
        int x = evt.getX(), y = evt.getY();
        x = (x < 0) ? 0 : x;
        y = (y < 0) ? 0 : y;
        x = (x > resized_width) ? resized_width : x;
        y = (y > resized_height) ? resized_height : y;

        //Work on real image coordinates
        int real_x = (int) (x / resize_factor);
        int real_y = (int) (y / resize_factor);
        Point p = new Point(real_x, real_y);
        //If the user presses the mouse in the interior of a area, he can move it.
        if (!selectedAreas.isEmpty() && selectedAreas.get(current_area).contains(p) &&
                !corners[0].contains(p) && !corners[1].contains(p) && !corners[2].contains(p) && !corners[3].contains(p)) {
            draw_mode = MOVE;
            loc_point = new Point((int) (x / resize_factor), (int) (y / resize_factor));
            this.setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
        } //If the user doesn't press on any of the corners, it's free area selection.
        else if (!corners[0].contains(p) && !corners[1].contains(p) && !corners[2].contains(p) && !corners[3].contains(p)) {
            origin_point = new Point((int) (x / resize_factor), (int) (y / resize_factor));
            end_point = new Point((int) (x / resize_factor), (int) (y / resize_factor));
            draw_mode = FREE_SELECTION;
            this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        } //The other option is that he pressed a corner, so he can resize.
        else {
            if (corners[0].contains(p)) {
                draw_mode = LU_CORNER;
                this.setCursor(Cursor.getPredefinedCursor(Cursor.NW_RESIZE_CURSOR));
            } else if (corners[1].contains(p)) {
                draw_mode = RU_CORNER;
                this.setCursor(Cursor.getPredefinedCursor(Cursor.NE_RESIZE_CURSOR));
            } else if (corners[2].contains(p)) {
                draw_mode = LD_CORNER;
                this.setCursor(Cursor.getPredefinedCursor(Cursor.SW_RESIZE_CURSOR));
            } else if (corners[3].contains(p)) {
                draw_mode = RD_CORNER;
                this.setCursor(Cursor.getPredefinedCursor(Cursor.SE_RESIZE_CURSOR));
            }
        }
    }
}//GEN-LAST:event_formMousePressed

public void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked

    //On click see if a area as been selected.
    if (evt.getButton() == java.awt.event.MouseEvent.BUTTON1) {
        //Get in real coordinates the click point
        click_point = new Point((int) (evt.getX() / resize_factor), (int) (evt.getY() / resize_factor));
        //See if an area contains that point
        Iterator<Rectangle> selectp = selectedAreas.iterator();
        boolean found = false;
        int current = 0;
        while (selectp.hasNext() && !found) {
            Rectangle area = selectp.next();
            if (area.contains(click_point)) {
                current_area = current;
                found = true;
            }
            current++;
        }
        if (found) //If found repaint.
        {
            repaint();
        }
    }
}//GEN-LAST:event_formMouseClicked

public void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
    this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
}//GEN-LAST:event_formMouseReleased

      // Variables declaration - do not modify//GEN-BEGIN:variables
      // End of variables declaration//GEN-END:variables
    @Override
    //Override to the paint method in order to print the image and areas
    public void paint(Graphics g) {
        super.paint(g);

        this.setBackground(java.awt.Color.BLACK);

        if (panel_image != null) {
            Graphics2D g2d = (Graphics2D) g;

            //Area painting stroke
            float dash1[] = {10.0f};
            BasicStroke dashedStroke = new BasicStroke(1.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash1, 0.0f);
            g2d.setStroke(dashedStroke);


            g2d.setComposite(makeComposite(0.1f));
            //Paint the not confirmed selection on image in green.
            g2d.setPaint(Color.GREEN);
            int min_x = Math.min(origin_point.x, end_point.x),
                    min_y = Math.min(origin_point.y, end_point.y),
                    max_x = Math.max(origin_point.x, end_point.x),
                    max_y = Math.max(origin_point.y, end_point.y);
            g2d.fill(new Rectangle((int) (min_x * resize_factor), (int) (min_y * resize_factor), (int) ((max_x - min_x) * resize_factor), (int) ((max_y - min_y) * resize_factor)));

            //For a all confirmed areas
            Iterator<Rectangle> selectp = selectedAreas.iterator();
            int current = 0;

            while (selectp.hasNext()) {

                Rectangle area = selectp.next();

                g2d.setComposite(makeComposite(0.5f));

                //If is selected, paint in red.
                if (current == current_area) {

                    System.out.println("Pintar quadrados");
                    g2d.setPaint(Color.RED);

                    g2d.fill(new Rectangle((int) (area.x * resize_factor), (int) (area.y * resize_factor), (int) (area.width * resize_factor), (int) (area.height * resize_factor)));
                    //Paint the corners
                    corners[0] = new Rectangle((int) ((area.x - 8 / resize_factor)), (int) ((area.y - 8 / resize_factor)), (int) (16 / resize_factor), (int) (16 / resize_factor));
                    g2d.draw3DRect((int) ((area.x) * resize_factor - 4), (int) ((area.y) * resize_factor - 4), (int) (8), (int) (8), true);
                    corners[1] = new Rectangle((int) ((area.x + area.width - 8 / resize_factor)), (int) ((area.y - 8 / resize_factor)), (int) (16 / resize_factor), (int) (16 / resize_factor));
                    g2d.draw3DRect((int) ((area.x + area.width) * resize_factor - 4), (int) ((area.y) * resize_factor - 4), (int) (8), (int) (8), true);
                    corners[2] = new Rectangle((int) ((area.x - 8 / resize_factor)), (int) ((area.y + area.height - 8 / resize_factor)), (int) (16 / resize_factor), (int) (16 / resize_factor));
                    g2d.draw3DRect((int) ((area.x) * resize_factor - 4), (int) ((area.y + area.height) * resize_factor - 4), (int) (8), (int) (8), true);
                    corners[3] = new Rectangle((int) ((area.x + area.width - 8 / resize_factor)), (int) ((area.y + area.height - 8 / resize_factor)), (int) (16 / resize_factor), (int) (16 / resize_factor));
                    g2d.draw3DRect((int) ((area.x + area.width) * resize_factor - 4), (int) ((area.y + area.height) * resize_factor - 4), (int) (8), (int) (8), true);
                } //else blue if not selected
                else {
                    g2d.setPaint(Color.BLUE);
                    g2d.fill(new Rectangle((int) (area.x * resize_factor), (int) (area.y * resize_factor), (int) (area.width * resize_factor), (int) (area.height * resize_factor)));
                }
                current++;
            }
        }
    }

    protected AlphaComposite makeComposite(float alpha) {
        int type = AlphaComposite.SRC_OVER;
        return (AlphaComposite.getInstance(type, alpha));
    }

    /**
     *Set a area to be displayed on the image. Areas to big or to small will not be shown.
     *@param area The area to be displayed.
     */
    public void setSelectionArea(Rectangle area) {

        //Make sure that the area is valid
        if ((area.width * area.height == 0) || (Math.max(area.width, area.height) < 20)) {
            return;
        }
        if (area.x < 0 || area.y < 0) {
            return;
        }
        if ((area.x + area.width) * resize_factor > resized_width || (area.y + area.height) * resize_factor > resized_height) {
            return;
        }

        selectedAreas.add(area);
    }

    /**Set the indicated area selected.
    @param selec The area to select.
     */
    public void setSelected(int selec) {
        current_area = selec;
        this.repaint();
    }

    /**Get the last edited area.
    @return  a rectangle representing the last edited area.If none has been changed, null is returned.
     */
    public Rectangle getChangedSelection() {
        Rectangle sr = null;
        if (!selectedAreas.isEmpty() && changed) {
            sr = selectedAreas.get(current_area);
        }
        changed = false;
        return sr;
    }

    /**Delete the indicated area
    @param  The area to be removed.
     */
    public void deleteSelection(int delete_area) {

        if (selectedAreas.size() > delete_area - 1) {
            selectedAreas.remove(delete_area);
            if (selectedAreas.isEmpty()) {
                for (int i = 0; i < 4; i++) {
                    corners[i] = new Rectangle();
                }
                draw_mode = FREE_SELECTION;
            }
            repaint();
        }

    }

    /**Returns the current selected area
    @return a integetr indicating the selected area.
     */
    public int getSelectedArea() {
        return current_area;
    }

    /**Abs function*/
    private int abs(int x) {
        return (x < 0) ? 0 : x;
    }

    /**Confirms the current selected area and returns it.
    @return a selected area, nul, is nothing has selected.
     */
    public Rectangle confirmSelectionArea() {

        //Define the area
        int min_x = abs(Math.min(origin_point.x, end_point.x)),
                min_y = abs(Math.min(origin_point.y, end_point.y)),
                max_x = abs(Math.max(origin_point.x, end_point.x)),
                max_y = abs(Math.max(origin_point.y, end_point.y));
        Rectangle new_rect = new Rectangle(min_x, min_y, max_x - min_x, max_y - min_y);
        //Area to return
        Rectangle area = null;
        int max = Math.max(max_x - min_x, max_y - min_y);
        //If area is not null and has a minimal width and height
        if ((max_x - min_x * max_y - min_y != 0) && (max > 30)) {
            //reset variables
            selectedAreas.add(new_rect);
            origin_point.setLocation(0, 0);
            end_point.setLocation(0, 0);
            current_area = selectedAreas.size() - 1;
            //define area to return
            area = new_rect;
            this.repaint();
        }
        return area;
    }

    /**Panel reset method. All areas will be eliminated and current image will be erased*/
    public void reset() {

        selectedAreas = new ArrayList<Rectangle>();
        origin_point = new Point();
        end_point = new Point();
        current_area = 0;
        click_point = new Point();
        resized_width = 0;
        resized_height = 0;
        resize_factor = 1;
        resized_image = null;
        panel_image = null;
        corners = new Rectangle[]{new Rectangle(), new Rectangle(), new Rectangle(), new Rectangle()};
        java.lang.Runtime.getRuntime().gc();
        draw_mode = FREE_SELECTION;
    }
}
