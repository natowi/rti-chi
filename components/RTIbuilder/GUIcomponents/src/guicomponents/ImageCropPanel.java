/*
 *  RTIbuilder
 *  Copyright (C) 2008-11  Universidade do Minho and Cultural Heritage Imaging
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License version 3 as published
 *  by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package guicomponents;

import guicomponents.exceptions.AreaNotDefined;
import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.util.ArrayList;

/**Image Crop panel used for image edition.<p> The panel has two modes:<br>
 *  <li>Free crop mode: the user can make a crop polygon by laying dots on the image.<br>
 *  <li>Rectangle crop: the user can select a rectangular area on image to crop.<br>
 */
public class ImageCropPanel extends PreviewPanel {
 
	/**Crop disable*/
	public static final int CROP_DISABLE =0;
	/**Crop type with a rectangular area*/
    public static final int RECTANGULAR_CROP = 1;
	/**Crop type with a polygon area*/
    public static final int FREE_CROP = 2;
	/**Crop type used in the panel*/
	private int CropType = 0;

	/**Initial crop point*/
    private Point initPoint = new Point();
	/**End crop point*/
    private Point endPoint = new Point();
	/**Crop Area*/
    private ArrayList<Point> CropPoints = new ArrayList<Point>();



    /** Creates new form ImageGridPanel */
    public ImageCropPanel() {
        super();
		super.setUserDefinedScale(false);
		initComponents();

    }

    /** Creates new form ImageGridPanel with a new image*/
    public ImageCropPanel(BufferedImage bi) {
        super();
		super.setUserDefinedScale(false);
		initComponents();
        this.panel_image = bi;

    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {

            @Override
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {

            @Override
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
        });
		addMouseListener(new java.awt.event.MouseAdapter() {

            @Override
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
        });
    }// </editor-fold>                        

    public void formMousePressed(java.awt.event.MouseEvent evt) {
	    //if mouse is pressed
        switch(CropType){
			//If rectangular crop
            case RECTANGULAR_CROP :
				 //if left mouse button
                 if(evt.getButton()==java.awt.event.MouseEvent.BUTTON1){
                    int x = evt.getX(),y = evt.getY();
                    x = (x<0)? 0 : x;
                    y = (y<0)? 0 : y; 
                    x = (int) ((x > resized_width) ? resized_width : x);
                    y = (int) ((y > resized_height) ? resized_height : y);
					//Sets in a new crop area, the initial and final points, allways in real size scale.
                    initPoint = new Point((int) (x/resize_factor),(int) (y/resize_factor));
                    endPoint = new Point((int) (x/resize_factor),(int) (y/resize_factor));
                }
                break;
            //If free crop
            case FREE_CROP:
				//if left mouse button and control button are pressed, close the area
                if (evt.getButton() == java.awt.event.MouseEvent.BUTTON1 && evt.isControlDown()) 
                {

                    if (CropPoints.size() > 1) 
                    {
						//If the crop area has more than one point, the last point becomes the first to close the area.
                        CropPoints.add(CropPoints.get(0));
                    }
                }
				//If the left mouse button is clicked
				else if (evt.getButton() == java.awt.event.MouseEvent.BUTTON1&&evt.getClickCount()==1) {

					int i = (int) Math.floor(evt.getX());
                    int j = (int) Math.floor(evt.getY());
					//Put the point inside the picture
                    i = (i>resized_width) ?  (int) Math.floor(resized_width) : i;
				    i = (i<0) ?  0 : i;
				    j = (j>resized_height) ?  (int) Math.floor(resized_height) : j;
                    j = (j<0) ?  0 : j;
					//Store the new point
                    Point newPoint = new Point((int)(i/resize_factor),(int)(j/resize_factor));
                    CropPoints.add(newPoint);
                }
				//If the right mouse button is clicked and control key is down
                else if (evt.getButton() == java.awt.event.MouseEvent.BUTTON3  && evt.isControlDown()) 
                {
					//Clear crop area.
                    CropPoints = new ArrayList<Point>();
                }
			    //If the right mouse button is pressed
                else if (evt.getButton() == java.awt.event.MouseEvent.BUTTON3&&!CropPoints.isEmpty()) 
                {
					//remove last point
                    CropPoints.remove(CropPoints.size() - 1);
                }
                this.repaint();

                break;                                                  
        }
     
    }

   public void formMouseDragged(java.awt.event.MouseEvent evt) {
        //If mouse dragged with left mouse button, and the crop type is rectangular
        if(CropType == RECTANGULAR_CROP&&(evt.getModifiersEx() & java.awt.event.InputEvent.BUTTON1_DOWN_MASK)==java.awt.event.InputEvent.BUTTON1_DOWN_MASK)
        {
            int x = evt.getX(),y = evt.getY();
            x = (x<0)? 0 : x;
            y = (y<0)? 0 : y; 
            x = (int) ((x > resized_width) ? resized_width : x);
            y = (int) ((y > resized_height) ? resized_height : y);
            //Set the rectangle end point, to set a new area.
            endPoint =  new Point((int) (x/resize_factor),(int) (y/resize_factor));
            repaint();
        }
        
    }
   
   public void formMouseClicked(java.awt.event.MouseEvent evt){
			//On left double click
		    if(evt.getButton() == java.awt.event.MouseEvent.BUTTON1&&evt.getClickCount()==2){
			        if (CropPoints.size() > 1) 
                    {
						//Close area, if crop points number is bigger than one.
                        CropPoints.add(CropPoints.get(0));
                    }
			}
			this.repaint();
   }

    // Variables declaration - do not modify                     
    // End of variables declaration                   
    @Override
    public void paint(Graphics g) {
        super.paint(g);

        if (panel_image != null) {

            Graphics2D g2d = (Graphics2D) g;
			//If crop enable
            if (CropType==RECTANGULAR_CROP||CropType==FREE_CROP) {

                g.setColor(java.awt.Color.RED);
                float dash1[] = {10.0f};
                BasicStroke dashedStroke = new BasicStroke(1.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10.0f, dash1, 0.0f);
                g2d.setStroke(dashedStroke);

                switch(CropType){
					//If free crop
                    case FREE_CROP :                
                        Point prev = null;
						if (!CropPoints.isEmpty()) {
                            prev = CropPoints.get(0);
                            //for all points
							for (Point point : CropPoints) {
                                //draw a line from the previous point to the actual.
								g2d.drawLine((int)(prev.x*resize_factor), (int)(prev.y*resize_factor), (int)(point.x*resize_factor), (int)(point.y*resize_factor));
                                prev = point;
                             }
                        }
                        if( CropPoints.size()>1)
                        {
						    //If the initial crop point equals the final, the area is closed
                            if(CropPoints.get(0).equals(CropPoints.get(CropPoints.size()-1)))
                            {

                                Polygon pol = new  Polygon();
                                //Make the polygon
								for(Point p :CropPoints)
                                    pol.addPoint((int)(p.x*resize_factor),(int)(p.y*resize_factor));
                                g2d.setComposite(makeComposite(0.1f));
                                g2d.setPaint(Color.GREEN);
                                //Fill it in green.
								g2d.fill(pol);
                            }
                        }
                        break;
				   //If rectangular crop
                    case RECTANGULAR_CROP :
                        //Define the area
						int min_x=Math.min(initPoint.x, endPoint.x),
                            min_y=Math.min(initPoint.y, endPoint.y),
                            max_x=Math.max(initPoint.x, endPoint.x),
                            max_y=Math.max(initPoint.y, endPoint.y); 
                        g2d.setComposite(makeComposite(0.1f));
                        g2d.setPaint(Color.GREEN);
						//fill the rectangle in green
                        g2d.fill(new Rectangle((int)(min_x*resize_factor),(int)(min_y*resize_factor),(int)((max_x-min_x)*resize_factor),(int)((max_y-min_y)*resize_factor)));
                        break;
                }                
            }
        }

    }

    private AlphaComposite makeComposite(float alpha) {
        int type = AlphaComposite.SRC_OVER;
        return (AlphaComposite.getInstance(type, alpha));
    }

	/**
	*Sets crop points in panel and repaints it.<p>
	*@param Crop_points a array list of points representing a crop area.
	*/
    public void setCropPoints(ArrayList<Point> Crop_points) {
        if(CropType == FREE_CROP){
            this.CropPoints = Crop_points;
        }else{
            if(Crop_points.size() == 4){
                initPoint = Crop_points.get(0);
                endPoint = Crop_points.get(2);
            }

        }
        
		//repaint();
    }
    
    public void cleanCropArea(){
        if(this.CropType == this.FREE_CROP){
            this.CropPoints = new ArrayList<Point>();
        }else{
            this.initPoint = new Point();
            this.endPoint = new Point();
        }
        repaint();
    }



	/**
	 *Get the panel current crop area through an array of points.<br>If the area is not closed a exception is thrown.
     * <br>If none area is defined, an empty arraylist is returned.
	 *@return ArrayList of Points with the selected area.
     *@exception AreaNotDefined
	 */
	public ArrayList<Point> getCropPoints() throws AreaNotDefined {
            
		ArrayList<Point> crop_points  =  new ArrayList<Point>();

        if (CropType == FREE_CROP) {
            for (Point p : CropPoints) {
                int x = p.x;
                int y = p.y;
                crop_points.add(new Point(x, y));
            }
            if(!CropPoints.get(0).equals(CropPoints.get(CropPoints.size()-1))){
                throw new AreaNotDefined("The area is not closed");
            }
        }
        if (CropType == RECTANGULAR_CROP) {
            if(this.initPoint.equals(endPoint)) return crop_points;
             crop_points = new ArrayList<Point>();
             int min_x=(int) (Math.min(initPoint.x, endPoint.x)),
                 min_y=(int) (Math.min(initPoint.y, endPoint.y)),
                 max_x=(int) (Math.max(initPoint.x, endPoint.x)),
                 max_y=(int) (Math.max(initPoint.y, endPoint.y));
             crop_points.add(new Point(min_x,min_y));
             crop_points.add(new Point(max_x,min_y));
             crop_points.add(new Point(max_x,max_y));
             crop_points.add(new Point(min_x,max_y));
        }         
        return crop_points;
    }

    /**
	*Set the panel crop type, or disable it. Legal values are:<p>
	 * <li> CROP_DISABLE - disable crop.
	 * <li> RECTANGULAR_CROP - sets crop type to rectangular crop.
	 * <li> FREE_CROP - sets crop to free crop.
	 * @param crop the crop type to be implemented.
	*/
    public void setCropType(int crop){
        //If the user wants to change to rectangular crop, and the crop was set to free
        if(CropType==FREE_CROP&&crop ==RECTANGULAR_CROP)
        {
                if( CropPoints.size()>1)
                {
					//If it is a closed area
                    if(CropPoints.get(0).equals(CropPoints.get(CropPoints.size()-1)))
                    {
						//make the polygon
                        Polygon pol = new  Polygon();
                        for(Point p :CropPoints)
                            pol.addPoint((int)(p.x),(int)(p.y));
                        //draw a rectangle around the borders
						Rectangle rec =pol.getBounds();
                        initPoint = new Point(rec.x,rec.y);
                        endPoint = new Point(rec.x+rec.width,rec.y+rec.height);
                    }
                }
        
        }
		//If the user changes to free crop and panel crop was the rectangular crop
        else if(CropType==RECTANGULAR_CROP&&crop ==FREE_CROP)
        {
			 //Take the rectangular crops
             CropPoints = new ArrayList<Point>();
              int min_x=Math.min(initPoint.x, endPoint.x),
                   min_y=Math.min(initPoint.y, endPoint.y),
                   max_x=Math.max(initPoint.x, endPoint.x),
                   max_y=Math.max(initPoint.y, endPoint.y);
             //If the rectangle is not empty draw the rectangle lines, like in a polygon.
			  if(min_x!=max_x)
              {
             CropPoints.add(new Point(min_x,min_y));
             CropPoints.add(new Point(max_x,min_y));
             CropPoints.add(new Point(max_x,max_y));
             CropPoints.add(new Point(min_x,max_y));
             CropPoints.add(new Point(min_x,min_y));
             }
        }
		//Set crop type
        CropType = crop;
        this.repaint();
    }

    /**
	*Enables/disables crop option on panel.<p>
	*@param flag true to enable crop, false otherwise.
	*/
    public void drawCrop(boolean flag) {
        if(!flag){
			CropPoints = new ArrayList<Point>();
			CropType = CROP_DISABLE;
		}
    }

	/**Panel reset method. All crop information will be deleted*/
    public void reset(){
        
        CropPoints = new ArrayList<Point>();
        initPoint = new Point();
        endPoint = new Point();
        panel_image =  null;
        CropType = 0;
        resized_width = 0;
        resized_height = 0;
        resize_factor = 1.0f;
    }

}
