/*
 *  RTIbuilder
 *  Copyright (C) 2008-11  Universidade do Minho and Cultural Heritage Imaging
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License version 3 as published
 *  by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package Plugin.helpers;
import Exceptions.*;
import Plugin.Exceptions.PathUndefined;
import XMLcarrier.Exceptions.UUIDNotFound;
import java.io.File;
import XMLcarrier.*;
import java.awt.Cursor;
import java.awt.Point;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.TreeMap;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.media.jai.JAI;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextArea;

/**
 *
 * @author matheus
 */
public class HSHFitterThread implements Runnable{

    /**
     * Saves the absolute path to the fitter;
     */
    private StringBuffer FITTER_ABSOLUTE_PATH;

    /**
     * Saves all the arguments that the fitter needs;
     */
    private StringBuffer COMMAND_LINE_ARGUMENTS;

    private String[] argsList;


    /**
     * Light Position absolute path;
     */
    private StringBuffer LP_ABSOLUTE_PATH;


    /**
     * Non-cropped export images path
     */
    private String EXPORT_PATH;

    /*
     * Width and height of the final RTI.
     * Need to be compared with the original image set to check if it needs to be resized.
     *
     */
    private int WIDTH;
    private int HEIGHT;

    private int ORIGINAL_WIDTH;
    private int ORIGINAL_HEIGHT;


    /**
     * PTMFitter use
     * LRGB or RGB. If not specified, RGB will be used.
     *
     */
    private final short PTM_RGB = 2;
    private final short PTM_LRGB = 1;
    private short PTM_TYPE;
    private final short PTM_TYPE_DEFAULT = PTM_RGB;

    /**
     * Output file name.
     * If not specified, the project name will be used.
     */
    private String OUTPUT_FILE_NAME;

    private final String ERROR_PROJECT_NAME = "NO_PROJECT_NAME";

    /**
     * This var will hold all the output generated by the fitter in the stdout;
     */
    private StringBuffer fitterOutput;

    /**
     * Have to do this way to avoid unacessary concurrency problems;
     *
     */
    JTextArea textArea;

    private String xmlPath;

    private String PROJECT_PATH;

    private boolean toResize = false;

    private boolean existingLP = false;

    private UUID sphereID;

    private String finishedFilesDir;

    private String assemblyFilesDir;

    private String PROJECT_NAME;

    private boolean cropUsed = false;

    private String CROPPED_DIR = "";

    private JButton buttonExecute;

    private int cropHeight;
    private int cropWidth;

    private String cmdRest;

    private ArrayList<Point> pointList;

    //1 - free; 0 - rectangular
    private boolean cropStyle;


    private int performanceProfile = 0;
    private int memoryProfile = 0;
    private boolean compressOutput = false;
    private int orderSetting = 3;
    private String colorCorrection = "";
    private int numProcs = 1;
    private boolean useAdvOpt = true;

    public HSHFitterThread(String xmlpath){
        this.COMMAND_LINE_ARGUMENTS = new StringBuffer();
       
        this.FITTER_ABSOLUTE_PATH = new StringBuffer();

        this.LP_ABSOLUTE_PATH = new StringBuffer();

        this.existingLP = false;

        this.xmlPath = xmlpath;

        this.PTM_TYPE = this.PTM_TYPE_DEFAULT;
        this.fitterOutput = new StringBuffer();

        try{
            XMLHandler a = new XMLHandler(xmlpath);
            a.loadXML();
            HeaderInfo hi = a.getProjectInfo();
            TreeMap<String,String> info = hi.getMap();

            this.finishedFilesDir = hi.getFinishedFilesDirectory();
            this.assemblyFilesDir = hi.getAssemblyFilesDirectory();
            this.CROPPED_DIR = hi.getCroppedDir();
            if(this.CROPPED_DIR == null || this.CROPPED_DIR.equals("")){
                this.CROPPED_DIR = "CROPPED";
            }
            this.EXPORT_PATH = hi.getJpegExportsDirectory();

           /* this.finishedFilesDir = "finishedfiles";
            this.assemblyFilesDir = "assemblyfiles";*/

            this.ORIGINAL_WIDTH = (Float.valueOf(info.get("Image width"))).intValue();
            this.ORIGINAL_HEIGHT = (Float.valueOf(info.get("Image height"))).intValue();

            this.WIDTH = this.ORIGINAL_WIDTH;
            this.HEIGHT = this.ORIGINAL_HEIGHT;

            this.PROJECT_PATH = info.get("ProjectPath") + File.separator;

            this.PROJECT_NAME = hi.getProjectName();

            RawInfo ri = a.getComputedInfo("LightDirections");

            if(!(ri.getAttribute("SphereID") == null)){
                //Means we dont have any lightDirections and we need to calculate it later.
                this.existingLP = true;
            }else{
                this.existingLP = false;
            }

            this.OUTPUT_FILE_NAME = hi.getProjectName();
        }catch(Exception e){
            e.printStackTrace();
            this.OUTPUT_FILE_NAME = this.ERROR_PROJECT_NAME + ".rti";
        }

    }

    public HSHFitterThread(String xmlpath,String fitterPath,String lp,String output,UUID sphereID){
        this.COMMAND_LINE_ARGUMENTS = new StringBuffer();
        this.FITTER_ABSOLUTE_PATH = new StringBuffer();
        this.FITTER_ABSOLUTE_PATH.append(fitterPath);

        this.LP_ABSOLUTE_PATH = new StringBuffer();
        //this.LP_ABSOLUTE_PATH.append(lp);

        this.PTM_TYPE = 1;//type;

        this.fitterOutput = new StringBuffer();

        this.xmlPath = xmlpath;

        try{
            XMLHandler a = new XMLHandler(xmlpath);
            a.loadXML();

            Event e = new Event();
            e.setLevel(Level.INFO.toString());
            e.setText("HSHfitter auxiliar started");

            a.registEvent(e);

            HeaderInfo hi = a.getProjectInfo();
            TreeMap<String,String> info = hi.getMap();

            this.finishedFilesDir = hi.getFinishedFilesDirectory();
            this.assemblyFilesDir = hi.getAssemblyFilesDirectory();
            this.CROPPED_DIR = hi.getCroppedDir();
            if(this.CROPPED_DIR == null || this.CROPPED_DIR.equals("")){
                this.CROPPED_DIR = "CROPPED";
            }
            this.EXPORT_PATH = hi.getJpegExportsDirectory();

            /*this.finishedFilesDir = "finishedfiles";
            this.assemblyFilesDir = "assemblyfiles";*/

            this.ORIGINAL_WIDTH = (Float.valueOf(info.get("Image width"))).intValue();
            this.ORIGINAL_HEIGHT = (Float.valueOf(info.get("Image height"))).intValue();

            this.WIDTH = this.ORIGINAL_WIDTH;
            this.HEIGHT = this.ORIGINAL_HEIGHT;
            this.PROJECT_PATH = info.get("ProjectPath") + File.separator;

            this.PROJECT_NAME = hi.getProjectName();

            RawInfo ri = a.getComputedInfo("LightDirections");

            if(!(ri.getAttribute("SphereID") == null)){
                this.existingLP = true;
            }else{
                this.existingLP = false;
            }

            this.setOutputName(output);
        }catch(Exception e){
            e.printStackTrace();
            this.OUTPUT_FILE_NAME = this.ERROR_PROJECT_NAME + ".rti";
        }

        this.sphereID = sphereID;

    }

    private boolean writeLP(UUID sphereID){
        XMLHandler xml = new XMLHandler(this.xmlPath);
        FileWriter fw = null;
        PrintWriter pw = null;
        try{
            xml.loadXML();

            Event evtlp = new Event();
            evtlp.setLevel(Level.INFO.toString());
            evtlp.setText("Writing LP for sphere : " + sphereID.toString() + " in directory : " +
                    this.PROJECT_PATH + this.assemblyFilesDir + File.separator);

            RawInfo ri = xml.getComputedInfo("LightDirections","SphereID",sphereID.toString());
            ArrayList<Info> innerList = ri.getAllInnerInformation();

            File assemblyFolder = new File(this.PROJECT_PATH + this.assemblyFilesDir
                    + File.separator);

            if(!assemblyFolder.exists()){
                assemblyFolder.mkdirs();
                //evtlp.setText(" that does not exists. Creating it!");
            }else{
                //evtlp.setText(" that exists. Do not need to create it!");
            }

            xml.registEvent(evtlp);

            if(this.cropUsed){
                fw = new FileWriter(this.PROJECT_PATH + this.assemblyFilesDir
                    + File.separator + this.PROJECT_NAME + "_cropped.lp");

                this.LP_ABSOLUTE_PATH.append(this.PROJECT_PATH + this.assemblyFilesDir
                    + File.separator + this.PROJECT_NAME + "_cropped.lp");
            }else{
                fw = new FileWriter(this.PROJECT_PATH + this.assemblyFilesDir
                    + File.separator + this.PROJECT_NAME + ".lp");

                this.LP_ABSOLUTE_PATH.append(this.PROJECT_PATH + this.assemblyFilesDir
                    + File.separator + this.PROJECT_NAME + ".lp");
            }

            
            
            pw = new PrintWriter(fw);

            pw.println(innerList.size()); //Number of images used

            if(innerList.size() == 0){
                Event e = new Event();
                e.setLevel(Level.SEVERE.toString());
                e.setText("Lp file with 0 images used!HSH will not be generated!");
                JOptionPane.showMessageDialog(null, "Lp file with 0 images used!HSH will not be generated!");
                xml.registEvent(e);
            return false;

            }else{
                Event e = new Event();
                e.setLevel(Level.INFO.toString());
                e.setText("Number of images used : " + innerList.size());
                xml.registEvent(e);
            }

            if(this.toResize){
                Event evt = new Event();
                evt.setLevel(Level.INFO.toString());
                evt.setText("Need to resize images!");
                xml.registEvent(evt);
                String filePath = "";
                try {
                    Info i = innerList.get(0);
                    filePath = xml.getImageByUUID(UUID.fromString(i.getAttribute("ImageID"))).getUrl();
                    
                    if(filePath.trim().contains(" ")){
                        JOptionPane.showMessageDialog(null, "Path for some images contains invalid characters. The fitter will not run properly");
                        Event e = new Event();
                        e.setLevel(Level.SEVERE.toString());
                        e.setText("Path for some images contains invalid characters. The fitter will not run properly");
                        xml.registEvent(e);
                        
                    }else{
                        Event e = new Event();
                        e.setLevel(Level.INFO.toString());
                        e.setText("Valid image's paths indeed!");
                        xml.registEvent(e);
                    }


                } catch (UUIDNotFound ex) {
                     //Logger.getLogger(HSHFitterThread.class.getName()).log(Level.SEVERE, null, ex);
                    ex.printStackTrace();
                }

                boolean test = true;

                    for(Info i: innerList){
                        try {
                            filePath = xml.getImageByUUID(UUID.fromString(i.getAttribute("ImageID"))).getUrl();
                        } catch (UUIDNotFound ex) {
                            //Logger.getLogger(HSHFitterThread.class.getName()).log(Level.SEVERE, null, ex);
                            ex.printStackTrace();
                        }

                        if(filePath.trim().contains(" ")){
                            if(test){
                                JOptionPane.showMessageDialog(null, "Path contains invalid characters. The fitter will not run properly");
                                test = false;
                            }


                            //pw.close();
                        //return false;
                        }//else{

                        if(cropUsed){
                            pw.println(this.PROJECT_PATH + CROPPED_DIR + "_jpeg_" + this.WIDTH + File.separator + new File(filePath).getName() +
                                    " " + i.getAttribute("x") + " " + i.getAttribute("y") + " " + i.getAttribute("z"));
                        }else{
                            pw.println(this.PROJECT_PATH + "jpeg_" + this.WIDTH + File.separator + new File(filePath).getName() +
                                    " " + i.getAttribute("x") + " " + i.getAttribute("y") + " " + i.getAttribute("z"));
                        }
                       // }
                    }
                }else{
                    Event evt = new Event();
                    evt.setLevel(Level.INFO.toString());
                    evt.setText("Dont need to resize images!");
                    xml.registEvent(evt);
                    String filePath = "";

                    try {
                        Info i = innerList.get(0);
                        filePath = xml.getImageByUUID(UUID.fromString(i.getAttribute("ImageID"))).getUrl();

                        if(filePath.trim().contains(" ")){
                            JOptionPane.showMessageDialog(null, "Path for some images contains invalid characters. The fitter will not run properly");
                            Event e = new Event();
                            e.setLevel(Level.SEVERE.toString());
                            e.setText("Path for some images contains invalid characters. The fitter will not run properly");
                            xml.registEvent(e);

                        }else{
                            Event e = new Event();
                            e.setLevel(Level.INFO.toString());
                            e.setText("Write LP : Valid image's paths indeed!");
                            xml.registEvent(e);
                        }

                     } catch (UUIDNotFound ex) {
                     //Logger.getLogger(HSHFitterThread.class.getName()).log(Level.SEVERE, null, ex);
                        ex.printStackTrace();
                    }

                    for(Info i: innerList){                        
                        try{
                            filePath = xml.getImageByUUID(UUID.fromString(i.getAttribute("ImageID"))).getUrl();
                        }catch(Exception e){
                            e.printStackTrace();
                        }
                        if(!cropUsed)
                            pw.println(this.PROJECT_PATH + filePath + " " + i.getAttribute("x") + " "
                                + i.getAttribute("y") + " " + i.getAttribute("z"));
                        else {
                            File aux = new File(filePath);

                            pw.println(this.PROJECT_PATH + this.CROPPED_DIR + File.separator + aux.getName() + " " + i.getAttribute("x") + " "
                                + i.getAttribute("y") + " " + i.getAttribute("z"));
                        }
                    /*System.out.println(i.getAgetImageByUUIDttribute("ImageURL") + " " +
                            i.getAttribute("x") + " " + i.getAttribute("y") + " " + i.getAttribute("z"));*/
                    }
                }
            }catch(Exception e){
                e.printStackTrace();
            }

            pw.close();
        try {
            //fw.close();
            xml.writeXML();
        } catch (Exception ex) {
            //Logger.getLogger(HSHFitterThread.class.getName()).log(Level.SEVERE, null, ex);
            ex.printStackTrace();
            //System.out.println("ParseException");
        }
            return true;
    }

    private boolean writeLP(){
        XMLHandler xml = new XMLHandler(this.xmlPath);
        FileWriter fw = null;
        PrintWriter pw = null;
        try{
            xml.loadXML();

             Event evtlp = new Event();
             evtlp.setLevel(Level.INFO.toString());
             evtlp.setText("Writing LP in directory : " +
                    this.PROJECT_PATH + this.assemblyFilesDir + File.separator);

            RawInfo ri = xml.getComputedInfo("LightDirections");
            ArrayList<Info> innerList = ri.getAllInnerInformation();

            File auxProjectPath = new File(this.PROJECT_PATH);
            if(!auxProjectPath.isDirectory())
                this.PROJECT_PATH = auxProjectPath.getParent() + File.separator;

            File assemblyFolder = new File(this.PROJECT_PATH + this.assemblyFilesDir
                    + File.separator);

            if(!assemblyFolder.exists()){
                assemblyFolder.mkdirs();
            }

            if(this.cropUsed){
                fw = new FileWriter(this.PROJECT_PATH + this.assemblyFilesDir
                    + File.separator + this.PROJECT_NAME + "_cropped.lp");

                this.LP_ABSOLUTE_PATH.append(this.PROJECT_PATH + this.assemblyFilesDir
                    + File.separator + this.PROJECT_NAME + "_cropped.lp");
            }else{
                fw = new FileWriter(this.PROJECT_PATH + this.assemblyFilesDir
                    + File.separator + this.PROJECT_NAME + ".lp");

                this.LP_ABSOLUTE_PATH.append(this.PROJECT_PATH + this.assemblyFilesDir
                    + File.separator + this.PROJECT_NAME + ".lp");
            }

            pw = new PrintWriter(fw);

            pw.println(innerList.size()); //Number of images used

            if(innerList.size() == 0){
                Event e = new Event();
                e.setLevel(Level.SEVERE.toString());
                e.setText("Lp file with 0 images used!HSH will not be generated!");
                JOptionPane.showMessageDialog(null, "Lp file with 0 images used!HSH will not be generated!");
                xml.registEvent(e);
            return false;

            }else{
                Event e = new Event();
                e.setLevel(Level.INFO.toString());
                e.setText("Number of images used : " + innerList.size());
                xml.registEvent(e);
            }


            if(this.toResize){
                Event evt = new Event();
                evt.setLevel(Level.INFO.toString());
                evt.setText("Need to resize images!");
                xml.registEvent(evt);
                
                String filePath = "";

                try {
                    Info i = innerList.get(0);
                    filePath = xml.getImageByUUID(UUID.fromString(i.getAttribute("ImageID"))).getUrl();

                    if(filePath.trim().contains(" ")){
                        JOptionPane.showMessageDialog(null, "Path for some images contains invalid characters. The fitter will not run properly");
                        Event e = new Event();
                        e.setLevel(Level.SEVERE.toString());
                        e.setText("Path for some images contains invalid characters. The fitter will not run properly");
                        xml.registEvent(e);

                    }else{
                        Event e = new Event();
                        e.setLevel(Level.INFO.toString());
                        e.setText("Valid image's paths indeed!");
                        xml.registEvent(e);
                    }


                } catch (UUIDNotFound ex) {
                     //Logger.getLogger(HSHFitterThread.class.getName()).log(Level.SEVERE, null, ex);
                    ex.printStackTrace();
                }

                    for(Info i: innerList){
                        try {
                            filePath = xml.getImageByUUID(UUID.fromString(i.getAttribute("ImageID"))).getUrl();
                        } catch (UUIDNotFound ex) {
                            //Logger.getLogger(HSHFitterThread.class.getName()).log(Level.SEVERE, null, ex);
                            ex.printStackTrace();
                        }

                        //if(filePath.trim().contains(" ")){
                            //JOptionPane.showMessageDialog(null, "Path contains invalid characters. The fitter will not run properly");
                            //pw.close();
                        //return false;
                        //}//else{

                        if(cropUsed){
                            pw.println(this.PROJECT_PATH + CROPPED_DIR + "_jpeg_" + this.WIDTH + File.separator + new File(filePath).getName() +
                                    " " + i.getAttribute("x") + " " + i.getAttribute("y") + " " + i.getAttribute("z"));
                        }else{
                            pw.println(this.PROJECT_PATH + "jpeg_" + this.WIDTH + File.separator + new File(filePath).getName() +
                                    " " + i.getAttribute("x") + " " + i.getAttribute("y") + " " + i.getAttribute("z"));
                        }
                        //}
                    }
                }else{

                    Event evt = new Event();
                    evt.setLevel(Level.INFO.toString());
                    evt.setText("Dont need to resize images!");
                    xml.registEvent(evt);
                    String filePath = "";

                    try {
                        Info i = innerList.get(0);
                        filePath = xml.getImageByUUID(UUID.fromString(i.getAttribute("ImageID"))).getUrl();

                        if(filePath.trim().contains(" ")){
                            JOptionPane.showMessageDialog(null, "Path for some images contains invalid characters. The fitter will not run properly");
                            Event e = new Event();
                            e.setLevel(Level.SEVERE.toString());
                            e.setText("Path for some images contains invalid characters. The fitter will not run properly");
                            xml.registEvent(e);

                        }else{
                            Event e = new Event();
                            e.setLevel(Level.INFO.toString());
                            e.setText("Write LP : Valid image's paths indeed!");
                            xml.registEvent(e);
                        }

                     } catch (UUIDNotFound ex) {
                     //Logger.getLogger(HSHFitterThread.class.getName()).log(Level.SEVERE, null, ex);
                        ex.printStackTrace();
                    }
                
                    for(Info i: innerList){
                        try{
                            filePath = xml.getImageByUUID(UUID.fromString(i.getAttribute("ImageID"))).getUrl();
                        }catch(Exception e){
                            e.printStackTrace();
                        }

                        if(!cropUsed)
                            pw.println(this.PROJECT_PATH + filePath + " " + i.getAttribute("x") + " "
                                + i.getAttribute("y") + " " + i.getAttribute("z"));
                        else {
                            File aux = new File(filePath);

                            pw.println(this.PROJECT_PATH + this.CROPPED_DIR + File.separator + aux.getName() + " " + i.getAttribute("x") + " "
                                + i.getAttribute("y") + " " + i.getAttribute("z"));
                        }
                    /*System.out.println(i.getAgetImageByUUIDttribute("ImageURL") + " " +
                            i.getAttribute("x") + " " + i.getAttribute("y") + " " + i.getAttribute("z"));*/
                    }
                }
            }catch(Exception e){
                e.printStackTrace();
            }

            pw.close();
            //fw.close();

            try {
            //fw.close();
                xml.writeXML();
            } catch (Exception ex) {
            //Logger.getLogger(HSHFitterThread.class.getName()).log(Level.SEVERE, null, ex);
                ex.printStackTrace();
                //System.out.println("ParseException");
            }

            return true;
    }

     private boolean writeLPOriginalSet(){
        XMLHandler xml = new XMLHandler(this.xmlPath);
        FileWriter fw = null;
        PrintWriter pw = null;
        try{
            xml.loadXML();

            RawInfo ri = xml.getComputedInfo("LightDirections");
            ArrayList<Info> innerList = ri.getAllInnerInformation();

            File auxProjectPath = new File(this.PROJECT_PATH);
            if(!auxProjectPath.isDirectory())
                this.PROJECT_PATH = auxProjectPath.getParent() + File.separator;

            File assemblyFolder = new File(this.PROJECT_PATH + this.assemblyFilesDir
                    + File.separator);

            if(!assemblyFolder.exists()){
                assemblyFolder.mkdirs();
            }

            fw = new FileWriter(this.PROJECT_PATH + this.assemblyFilesDir
                    + File.separator + this.PROJECT_NAME + "_OriginalSet" + ".lp");

            pw = new PrintWriter(fw);

            pw.println(innerList.size()); //Number of images used
            String filePath = "";
            
            for(Info i: innerList){
                        try {
                            filePath = xml.getImageByUUID(UUID.fromString(i.getAttribute("ImageID"))).getUrl();
                        } catch (UUIDNotFound ex) {
                            //Logger.getLogger(HSHFitterThread.class.getName()).log(Level.SEVERE, null, ex);
                            ex.printStackTrace();
                        }

                        //if(filePath.trim().contains(" ")){
                            //JOptionPane.showMessageDialog(null, "Path contains invalid characters. The fitter will not run properly");
                            //pw.close();
                        //return false;
                        //}//else{
                            pw.println(this.PROJECT_PATH + filePath +
                                    " " + i.getAttribute("x") + " " + i.getAttribute("y") + " " + i.getAttribute("z"));
                        //}
                    }

                    pw.close();

        }catch(Exception e){
            e.printStackTrace();
        }
     return true;
     }

    /**

     *
     * @throws FitterExceptions.PathUndefined
     */

     public int getCropHeight() {
        return cropHeight;
    }

    public void setCropHeight(int cropHeight) {
        this.cropHeight = cropHeight;
    }

    public void setCropWidth(int cropWidth) {
        this.cropWidth = cropWidth;
    }

    public void setCropWidthandHeight(int w,int h){
        this.cropHeight = h;
        this.cropWidth = w;
    }

/*
    private int performanceProfile = 0;
    private int memoryProfile = 0;
    private boolean compressOutput = false;
    private int orderSetting = 3;
    private boolean colorCorrection = false;
  */

    public void setPerformanceProfile(int p)
    {
        this.performanceProfile = p;
    }

    public void setMemoryProfile(int m)
    {
        this.memoryProfile = m;
    }

    public void setCompressOutput(boolean co)
    {
        this.compressOutput = co;
    }

    public void setColorCorrection(String cc)
    {
        this.colorCorrection = cc;
    }

    public void setOrderSetting(int os)
    {
        this.orderSetting = os;
    }

    private void getProcessorsForProfile()
    {
        if (this.performanceProfile == 1)
            this.numProcs = 1;
        else //if (this.performanceProfile == 0)
            this.numProcs = Runtime.getRuntime().availableProcessors();

        // Clustering is not supported by the fitter plugin yet
    }

    private static String readFileToString(File path) throws IOException
    {
        // Input stream for reading from
        InputStream is = new FileInputStream(path);

        // How big is the file?
        long length = path.length();

        // You cannot create an array using a long type.
        // It needs to be an int type.
        // Before converting to an int type, check
        // to ensure that file is not larger than Integer.MAX_VALUE.
        if (length > Integer.MAX_VALUE) {
            // File is too large
            throw new IOException("File is too large to handle! (>" + Integer.MAX_VALUE + " bytes!)");
        }

        // Create the byte array to hold the data
        byte[] bytes = new byte[(int)length];

        // Read in the bytes
        int offset = 0;
        int numRead = 0;
        while (offset < bytes.length
               && (numRead=is.read(bytes, offset, bytes.length-offset)) >= 0) {
            offset += numRead;
        }

        // Ensure all the bytes have been read in
        if (offset < bytes.length) {
            throw new IOException("Could not completely read file "+path.getName());
        }

        // Close the input stream and turn bytes into String
        is.close();

        String s = new String(bytes);

        return s;
    }

    private String generatePrefix()
    {
        String prefix = "";

        File path = new File(this.LP_ABSOLUTE_PATH.toString());

        // Read the entire file and commit to memory.
        String content = "";
        try {
            content = readFileToString(path);
        } catch (IOException ex) {
            Logger.getLogger(HSHFitterThread.class.getName()).log(Level.SEVERE, null, ex);
        }
        if (content.length() == 0) return "";

        // Now that the file is in memory, we'll parse it.
        float fl[] = new float[3];
        //int Index = -1;
        int i = 0;

        String[] Lines = content.split("\n");

        for (String l : Lines) {
            Pattern p = Pattern.compile("(-0\\.[0-9]+|0\\.[0-9]+)");
            Matcher m = p.matcher(l);

            i=0;
            while (m.find()) {
                String fls = m.group();
                fl[i] = Float.parseFloat(fls);
                l = l.replaceAll(fls, "");
                i++;
            }

            /* // Don't need the index
            if(i<3) continue;
            p = Pattern.compile("([0-9]+)");
            m = p.matcher(l);
            while (m.find()) {
                Index = Integer.parseInt(m.group());
            }*/

            File f = new File(l);
            String cmp = f.getName();

            if (prefix == null ? "" == null : prefix.equals(""))
                prefix = cmp;

            // Ensure only the matching substrings are left
            while (prefix == null ? cmp != null : !prefix.equals(cmp))
            {
                if (cmp.length() > prefix.length())
                    cmp = cmp.substring(0, cmp.length()-1);
                else
                {
                    cmp = cmp.substring(0, cmp.length()-1);
                    prefix = prefix.substring(0, prefix.length()-1);
                }
            }
        }

        return prefix;
    }

    // Generate Prabat's(?) syntax
    private boolean generateAdvCommandLineArgs() throws PathUndefined{
        /**
         * PTMFitter use:
         * ptmFitter -RBG(or LRGB) -i <light_position_file> -o <output_file_name>
         *
         */

        /**
         * HSHFitter use:
         * >> Usage : hshfitter <path_to_light_positions_file> <order> <output_file_name>
         * >> Usage : hshfitter <path_to_light_positions_file> <order> <MaxNumberOfThreads> <output_file_name>
         * >> Usage : hshfitter <path> <prefix> <order> <light_positions_file> <color_correction_file> <use_row_based_reader> <compressed>
         * >> Usage : hshfitter <path> <prefix> <order> <light_positions_file> <color_correction_file> <use_row_based_reader> <compressed> <MaxNumberOfThreads>
         * >>   Example 1 : ./hshfitter /home/matheus/snooker2/assembly-files/teste.lp 2 2 /home/matheus/Desktop/partilhaVB/snooker.hsh
         * >>   Example 2 : ./hshfitter /home/matheus/snookerPrabath/jpeg-exports/ snooker-test-1-_00 2 teste.lp nofile.txt true true
         */
       this.argsList = new String[9];

        if (this.sphereID == null && !this.cropUsed)
        {
            String originalLP = this.PROJECT_PATH + this.assemblyFilesDir + File.separator + this.PROJECT_NAME + "_OriginalSet" + ".lp";
            //File lpF = new File(originalLP);

            this.LP_ABSOLUTE_PATH.append(originalLP);
        }
        else if(!this.existingLP)
        {
            //System.out.println("Vou escrever o lp");
            if(this.sphereID!=null && !this.writeLP(this.sphereID)){
                JOptionPane.showMessageDialog(null, "Cannot Continue!Verify your filepaths");
                try{
                    XMLHandler xml = new XMLHandler(xmlPath);
                    xml.loadXML();
                    Event e = new Event();
                    e.setLevel(Level.SEVERE.toString());
                    e.setText("The LP was not generated succesfully. The user will be notified!");
                    xml.registEvent(e);
                    xml.writeXML();
                }catch(Exception e){
                    e.printStackTrace();
                }
                return false;
            }
            else
            {
                if(!this.writeLP()){
                try{
                    XMLHandler xml = new XMLHandler(xmlPath);
                    xml.loadXML();
                    Event e = new Event();
                    e.setLevel(Level.SEVERE.toString());
                    e.setText("The LP was not generated succesfully. The user will be notified!");
                    xml.registEvent(e);
                    xml.writeXML();
                }catch(Exception e){
                    e.printStackTrace();
                }
                JOptionPane.showMessageDialog(null, "Cannot Continue!Verify your filepaths");
                return false;
                }
            }
        }else{
            //System.out.println("Vou escrever o lp mas n preciso computa-lo");
            if(!this.writeLP()){
                try{
                    XMLHandler xml = new XMLHandler(xmlPath);
                    xml.loadXML();
                    Event e = new Event();
                    e.setLevel(Level.SEVERE.toString());
                    e.setText("The LP was not generated succesfully. The user will be notified!");
                    xml.registEvent(e);
                    xml.writeXML();
                }catch(Exception e){
                    e.printStackTrace();
                }
                JOptionPane.showMessageDialog(null, "Cannot Continue!Verify your filepaths");
                return false;
            }
        }

        String tempPath = ""; // - Done
        String tempPrefix = ""; // - Done?
        String tempOrder = ""; // - Done
        String lpFile = ""; // - Done
        String colorCorr = ""; // - Done
        String rowBased = ""; // - Done
        String compressed = ""; // - Done
        String maxNumThreads = ""; // - Done

        tempOrder += this.orderSetting;
        compressed += this.compressOutput ? "True" : "False";
        this.getProcessorsForProfile();
        maxNumThreads += this.numProcs;
        rowBased += this.memoryProfile == 0 ? "False" : "True";
        lpFile = this.LP_ABSOLUTE_PATH.toString();
        colorCorr += this.colorCorrection;

        File auxProjectPath = new File(this.PROJECT_PATH);
        if (!auxProjectPath.isDirectory()) {
            this.PROJECT_PATH = auxProjectPath.getParent() + File.separator;
        }

        File imageFolder;
        if (this.cropUsed)
        {
            imageFolder = new File(this.PROJECT_PATH + File.separator + this.CROPPED_DIR + File.separator);
        }
        else
        {
            imageFolder = new File(this.PROJECT_PATH + File.separator + this.EXPORT_PATH + File.separator);
        }

        tempPath = imageFolder.getAbsolutePath();

        tempPrefix = this.generatePrefix();

        File fitter = new File(this.FITTER_ABSOLUTE_PATH.toString());
        if ((fitter.isFile()) && (fitter.canExecute())) {
            if (this.FITTER_ABSOLUTE_PATH.toString().contains(" ")) {
                this.COMMAND_LINE_ARGUMENTS.append("\"" + this.FITTER_ABSOLUTE_PATH + "\"" + " ");
                //System.out.println("FITTER ABSOLUTE PATH " + this.COMMAND_LINE_ARGUMENTS.toString());
            } else {
                this.COMMAND_LINE_ARGUMENTS.append(this.FITTER_ABSOLUTE_PATH + " ");
            }
            this.argsList[0] = this.FITTER_ABSOLUTE_PATH.toString();


         }else{
             throw new PathUndefined("Fitter not found or you dont have permissions to execute it");
         }

        this.COMMAND_LINE_ARGUMENTS.append(tempPath + " ");
        this.argsList[1] = tempPath;
        this.COMMAND_LINE_ARGUMENTS.append(tempPrefix + " ");
        this.argsList[2] = tempPrefix;
        this.COMMAND_LINE_ARGUMENTS.append(tempOrder + " ");
        this.argsList[3] = tempOrder;

        /*
        if(this.PTM_TYPE == this.PTM_RGB){
            this.COMMAND_LINE_ARGUMENTS.append("-RGB" + " ");

        }else{
            this.COMMAND_LINE_ARGUMENTS.append("-LRGB" + " ");
        }*/

        File lp = new File(this.LP_ABSOLUTE_PATH.toString());
        if ((lp.isFile()) && (lp.canRead())) {
            this.COMMAND_LINE_ARGUMENTS.append(this.LP_ABSOLUTE_PATH + " ");
        } else {
            throw new PathUndefined("LP file not found or you dont have permissions to read it");
        }
        this.argsList[4] = this.LP_ABSOLUTE_PATH.toString();

        File cc = new File(colorCorr);
        if ((cc.isFile()) && (cc.canRead())) {
            this.COMMAND_LINE_ARGUMENTS.append(colorCorr + " ");
        } else {
            throw new PathUndefined("Color correction file not found or you dont have permissions to read it");
        }
        this.argsList[5] = colorCorr;

        this.COMMAND_LINE_ARGUMENTS.append(rowBased + " ");
        this.argsList[6] = rowBased;
        this.COMMAND_LINE_ARGUMENTS.append(compressed + " ");
        this.argsList[7] = compressed;
        this.COMMAND_LINE_ARGUMENTS.append(maxNumThreads + " ");
        this.argsList[8] = maxNumThreads;

        File outputDir = new File(this.PROJECT_PATH + this.finishedFilesDir + File.separator);

        if (!outputDir.exists()) {
            outputDir.mkdirs();
        }

        //this.COMMAND_LINE_ARGUMENTS.append("-o " + outputDir.getAbsolutePath() + File.separator + this.OUTPUT_FILE_NAME);

        try {
            XMLHandler xml = new XMLHandler(this.xmlPath);
            xml.loadXML();

            Event e = new Event();
            e.setLevel(Level.WARNING.toString());
            e.setText("Command line to execute : " + this.COMMAND_LINE_ARGUMENTS.toString());
            xml.registEvent(e);
            xml.writeXML();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return true;
    }

    // Generate simplified (UM) syntax
    private boolean generateCommandLineArgs() throws PathUndefined{
        /**
         * PTMFitter use:
         * ptmFitter -RBG(or LRGB) -i <light_position_file> -o <output_file_name>
         *
         */

        /**
         * HSHFitter use:
         * >> Usage : hshfitter <path_to_light_positions_file> <order> <output_file_name>
         * >> Usage : hshfitter <path_to_light_positions_file> <order> <MaxNumberOfThreads> <output_file_name>
         * >> Usage : hshfitter <path> <prefix> <order> <light_positions_file> <color_correction_file> <use_row_based_reader> <compressed>
         * >> Usage : hshfitter <path> <prefix> <order> <light_positions_file> <color_correction_file> <use_row_based_reader> <compressed> <MaxNumberOfThreads>
         * >>   Example 1 : ./hshfitter /home/matheus/snooker2/assembly-files/teste.lp 2 2 /home/matheus/Desktop/partilhaVB/snooker.hsh
         * >>   Example 2 : ./hshfitter /home/matheus/snookerPrabath/jpeg-exports/ snooker-test-1-_00 2 teste.lp nofile.txt true true
         */
         this.argsList = new String[5];

        if (this.sphereID == null && !this.cropUsed)
        {
            String originalLP = this.PROJECT_PATH + this.assemblyFilesDir + File.separator + this.PROJECT_NAME + "_OriginalSet" + ".lp";
            //File lpF = new File(originalLP);

            this.LP_ABSOLUTE_PATH.append(originalLP);
        }
        else if(!this.existingLP)
        {
            //System.out.println("Vou escrever o lp");
            if(this.sphereID!=null && !this.writeLP(this.sphereID)){
                JOptionPane.showMessageDialog(null, "Cannot Continue!Verify your filepaths");
                try{
                    XMLHandler xml = new XMLHandler(xmlPath);
                    xml.loadXML();
                    Event e = new Event();
                    e.setLevel(Level.SEVERE.toString());
                    e.setText("The LP was not generated succesfully. The user will be notified!");
                    xml.registEvent(e);
                    xml.writeXML();
                }catch(Exception e){
                    e.printStackTrace();
                }
                return false;
            }
            else
            {
                if(!this.writeLP()){
                try{
                    XMLHandler xml = new XMLHandler(xmlPath);
                    xml.loadXML();
                    Event e = new Event();
                    e.setLevel(Level.SEVERE.toString());
                    e.setText("The LP was not generated succesfully. The user will be notified!");
                    xml.registEvent(e);
                    xml.writeXML();
                }catch(Exception e){
                    e.printStackTrace();
                }
                JOptionPane.showMessageDialog(null, "Cannot Continue!Verify your filepaths");
                return false;
                }
            }

        }else{
            //System.out.println("Vou escrever o lp mas n preciso computa-lo");
            if(!this.writeLP()){
                try{
                    XMLHandler xml = new XMLHandler(xmlPath);
                    xml.loadXML();
                    Event e = new Event();
                    e.setLevel(Level.SEVERE.toString());
                    e.setText("The LP was not generated succesfully. The user will be notified!");
                    xml.registEvent(e);
                    xml.writeXML();
                }catch(Exception e){
                    e.printStackTrace();
                }
                JOptionPane.showMessageDialog(null, "Cannot Continue!Verify your filepaths");
                return false;
            }
        }

        //String tempPath = ""; // - Done
        //String tempPrefix = ""; // - Done?
        String tempOrder = ""; // - Done
        String lpFile = ""; // - Done
        String maxNumThreads = ""; // - Done

        tempOrder += this.orderSetting;
        this.getProcessorsForProfile();
        maxNumThreads += this.numProcs;
        //lpFile = this.LP_ABSOLUTE_PATH.toString();

        File auxProjectPath = new File(this.PROJECT_PATH);
        if (!auxProjectPath.isDirectory()) {
            this.PROJECT_PATH = auxProjectPath.getParent() + File.separator;
        }

        /*File imageFolder;
        if (this.cropUsed) {
            imageFolder = new File(this.PROJECT_PATH + File.separator + this.CROPPED_DIR + File.separator);
        } else {
            imageFolder = new File(this.PROJECT_PATH + File.separator + this.EXPORT_PATH + File.separator);
        }*/

        //tempPath = imageFolder.getAbsolutePath();

        //tempPrefix = this.generatePrefix();

        File fitter = new File(this.FITTER_ABSOLUTE_PATH.toString());
        if ((fitter.isFile()) && (fitter.canExecute())) {
            if (this.FITTER_ABSOLUTE_PATH.toString().contains(" ")) {
                this.COMMAND_LINE_ARGUMENTS.append("\"" + this.FITTER_ABSOLUTE_PATH + "\"" + " ");
                //System.out.println("FITTER ABSOLUTE PATH " + this.COMMAND_LINE_ARGUMENTS.toString());
            } else {
                this.COMMAND_LINE_ARGUMENTS.append(this.FITTER_ABSOLUTE_PATH + " ");
            }
            this.argsList[0] = this.FITTER_ABSOLUTE_PATH.toString();
        } else {
            throw new PathUndefined("Fitter not found or you dont have permissions to execute it");
        }

        //this.COMMAND_LINE_ARGUMENTS.append(tempPath + " ");
        //this.COMMAND_LINE_ARGUMENTS.append(tempPrefix + " ");

        File lp = new File(this.LP_ABSOLUTE_PATH.toString());
        if ((lp.isFile()) && (lp.canRead())) {
            this.COMMAND_LINE_ARGUMENTS.append(this.LP_ABSOLUTE_PATH + " ");
        } else {
            throw new PathUndefined("LP file not found or you dont have permissions to read it");
        }
        this.argsList[1] = this.LP_ABSOLUTE_PATH.toString();

        this.COMMAND_LINE_ARGUMENTS.append(tempOrder + " ");
        this.argsList[2] = tempOrder; //this.LP_ABSOLUTE_PATH.toString();

        /*
        if(this.PTM_TYPE == this.PTM_RGB){
            this.COMMAND_LINE_ARGUMENTS.append("-RGB" + " ");

        }else{
            this.COMMAND_LINE_ARGUMENTS.append("-LRGB" + " ");
        }*/

        /*
        File lp = new File(this.LP_ABSOLUTE_PATH.toString());
        if ((lp.isFile()) && (lp.canRead())) {
            this.COMMAND_LINE_ARGUMENTS.append(this.LP_ABSOLUTE_PATH + " ");
        } else {
            throw new PathUndefined("File not found or you dont have permissions to read it");
        }*/

        this.COMMAND_LINE_ARGUMENTS.append(maxNumThreads + " ");
        this.argsList[3] = maxNumThreads;

        File outputDir = new File(this.PROJECT_PATH + this.finishedFilesDir + File.separator);

        if (!outputDir.exists()) {
            outputDir.mkdirs();
        }

        this.COMMAND_LINE_ARGUMENTS.append(outputDir.getAbsolutePath() + File.separator + OUTPUT_FILE_NAME);
        this.argsList[4] = outputDir.getAbsolutePath() + File.separator + OUTPUT_FILE_NAME;
        //this.COMMAND_LINE_ARGUMENTS.append("-o " + outputDir.getAbsolutePath() + File.separator + this.OUTPUT_FILE_NAME);

        try {
            XMLHandler xml = new XMLHandler(this.xmlPath);
            xml.loadXML();

            Event e = new Event();
            e.setLevel(Level.WARNING.toString());
            e.setText("Command line to execute : " + this.COMMAND_LINE_ARGUMENTS.toString());
            xml.registEvent(e);
            xml.writeXML();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return true;
    }

    /**
     * This method receives the new Width and Height.
     *
     */
    public void setImagesSize(int width,int height){
        this.WIDTH = width;
        this.HEIGHT = height;
        this.toResize = true;
    }


    /**
     * This method sets the output ptm file type. Types are available at the FittersAvailable class.
     *
     * @param type PTM type. (RGB or LRGB)
     */

    public void setPTMType(short type){
        this.PTM_TYPE = type;
    }

    public void setTextArea(JTextArea a){
        this.textArea = a;
    }

    /**
     * This methd sets the output name of the RTI.
     *
     */

    public void setOutputName(String name){
        this.OUTPUT_FILE_NAME = name;
        if(!this.OUTPUT_FILE_NAME.contains(".rti")){
            this.OUTPUT_FILE_NAME += ".rti";
        }
    }

    public void setCropDir(String d){
        this.CROPPED_DIR = d;
    }

    public void setCropPoints(ArrayList<Point> pList){
        this.pointList = pList;
    }

    private void resize(){
        System.out.println("Resized Function");
        ArrayList<String> imgList = new ArrayList<String>();
        XMLHandler xml = new XMLHandler(xmlPath);
        String resizedDirectory;
        int cont=1,total=0;

        try{
            xml.loadXML();
            RawInfo ri = xml.getComputedInfo("LightDirections");
            ArrayList<Info> innerList = ri.getAllInnerInformation();

            File auxResizePath = new File(this.PROJECT_PATH);

            if(!auxResizePath.isDirectory()) this.PROJECT_PATH = auxResizePath.getParent() + File.separator;

            File resizedDir = new File(this.PROJECT_PATH + "jpeg_" + this.WIDTH);

            if(!resizedDir.exists()){
                resizedDir.mkdirs();
            }

            if(innerList.size() != 0){
                
                total = innerList.size();

                if(resizedDir.isDirectory() && resizedDir.canWrite()){
                    for(Info i : innerList){
                        String id = i.getAttribute("ImageID");
                        ImageFile imgF = xml.getImageByUUID(UUID.fromString(id));
                        File f = new File(this.PROJECT_PATH + File.separator + imgF.getUrl());  // File f = new File(imgF.getUrl());
                        
                        if(f.isFile()&&f.canRead()){
                                if(ImageProcessing.ImageResize(f, resizedDir.getAbsolutePath() + File.separator, (this.HEIGHT/(this.ORIGINAL_HEIGHT*1.0f)),(this.WIDTH/(this.ORIGINAL_WIDTH*1.0f)))){
                                    this.textArea.setText(this.textArea.getText() + "Resizing Image " + cont + " of " + total + "\n");
                                }
                            
                        }

                        cont++;
                    }

                }else{
                    //System.out.println("Cannot create directory for temporary images!");
                    JOptionPane.showMessageDialog(null, "Cannot create directory for temporary images!");

                }

            }else{
                //System.out.println("Cannot find any LD information!");
                JOptionPane.showMessageDialog(null, "Cannot find any LD information!");
            }

        }catch(Exception e){
            e.printStackTrace();

        }

	}

    private void crop(){
        System.out.println("Crop Function");
        ArrayList<String> imgList = new ArrayList<String>();
        XMLHandler xml = new XMLHandler(xmlPath);
        int cont=1,total=0;

        try{
            xml.loadXML();
            RawInfo ri = xml.getComputedInfo("LightDirections");
            ArrayList<Info> innerList = ri.getAllInnerInformation();

            File auxResizePath = new File(this.PROJECT_PATH);

            if(!auxResizePath.isDirectory()) this.PROJECT_PATH = auxResizePath.getParent() + File.separator;

            File cropDir = new File(this.PROJECT_PATH + CROPPED_DIR);

            if(!cropDir.exists()){
                cropDir.mkdirs();
            }

            if(innerList.size() != 0){

                total = innerList.size();

                if(cropDir.isDirectory() && cropDir.canWrite()){
                    for(Info i : innerList){
                        String id = i.getAttribute("ImageID");
                        ImageFile imgF = xml.getImageByUUID(UUID.fromString(id));
                        File f = new File(this.PROJECT_PATH + File.separator + imgF.getUrl());  // File f = new File(imgF.getUrl());

                        if(f.isFile()&&f.canRead()){
                                if(ImageProcessing.Crop(f, cropDir.getAbsolutePath() + File.separator, pointList,cropStyle)){
                                    this.textArea.setText(this.textArea.getText() + "Cropping Image " + cont + " of " + total + "\n");
                                }

                        }

                        cont++;
                    }

                }else{
                    //System.out.println("Cannot create directory for temporary images!");
                    JOptionPane.showMessageDialog(null, "Cannot create directory for temporary images!");

                }

            }else{
                //System.out.println("Cannot find any LD information!");
                JOptionPane.showMessageDialog(null, "Cannot find any LD information!");
            }

        }catch(Exception e){
            e.printStackTrace();

        }

	}

    public void cropUsed(boolean b){
        this.cropUsed = b;
    }

    public void setCropStyle(boolean b){
        /* true means free crop
         * false means rectangular
         */
        
        this.cropStyle = b;
    }

    public void setButtonExecute(JButton buttonExecute) {
        this.buttonExecute = buttonExecute;
    }

    public void setAdvOpt(boolean opt) {
        this.useAdvOpt = opt;
    }

    public void resizePlusCrop(){
        ArrayList<String> imgList = new ArrayList<String>();
        XMLHandler xml = new XMLHandler(xmlPath);
        int cont=1,total;

        try{
            xml.loadXML();
            RawInfo ri = xml.getComputedInfo("LightDirections");
            ArrayList<Info> innerList = ri.getAllInnerInformation();

            File auxrc = new File(this.PROJECT_PATH);

            if(!auxrc.isDirectory()) this.PROJECT_PATH = auxrc.getParent() + File.separator;

            File dir = new File(this.PROJECT_PATH + CROPPED_DIR + "_jpeg_" + this.WIDTH);

            if(!dir.exists()){
                dir.mkdirs();
            }
            total = innerList.size();
            if(total != 0){

                if(dir.isDirectory() && dir.canWrite()){
                    for(Info i : innerList){
                        String id = i.getAttribute("ImageID");
                        ImageFile imgF = xml.getImageByUUID(UUID.fromString(id));
                        File f = new File(this.PROJECT_PATH + File.separator + imgF.getUrl());  // File f = new File(imgF.getUrl());

                        if(f.isFile()&&f.canRead()){
                            System.out.println("Width : " + this.WIDTH);

                            if(ImageProcessing.CropAndResize(f,dir.getAbsolutePath() + File.separator,(this.HEIGHT/(this.cropHeight*1.0f)),(this.WIDTH/(this.cropWidth*1.0f)),
                                    pointList,this.cropStyle)){
                                    this.textArea.setText(this.textArea.getText() + "Resizing and Cropping Image " + cont + " of " + total + "\n");


                            }
                            cont++;
                        }

                    }

                }else{
                    //System.out.println("Cannot create directory for temporary images!");
                    JOptionPane.showMessageDialog(null, "Cannot create directory for temporary images!");

                }

            }else{
                //System.out.println("Cannot find any LD information!");
                JOptionPane.showMessageDialog(null, "Cannot find any LD information!");
            }

        }catch(Exception e){
            e.printStackTrace();

        }
    }

    public void handleImages(){
        if((this.WIDTH != this.ORIGINAL_WIDTH)||(this.HEIGHT != this.ORIGINAL_HEIGHT)){
            //Resize

            if(this.cropUsed){
                //RESIZE + CROP
                try{
                    resizePlusCrop();
                    System.out.println("resizePlusCrop();");
                }catch(Exception e){
                    e.printStackTrace();
                }


            }else{
                try{
                    resize();
                }catch(Exception e){
                    e.printStackTrace();
                }
            }
        }else if(cropUsed){
            //JUST CROP
            try{
                crop();
            }catch(Exception e){
                e.printStackTrace();
            }
        }
            
    }

    public void run(){


        this.handleImages();
        this.writeLPOriginalSet();
        boolean res = false;
        boolean caught = false;
        try{
            if (!this.useAdvOpt)
            {
                res = this.generateCommandLineArgs();
            }
            else
            {
                res = this.generateAdvCommandLineArgs();
            }
        }catch(PathUndefined pu){
            //Need to throw this exception but...cannot override run throwing a new exception...
            caught = true;
            pu.printStackTrace();
            this.buttonExecute.setEnabled(true);
            JOptionPane.showMessageDialog(null, "Error: "+pu.toString());
        }
        try {
            if(!res){
                if (!caught) JOptionPane.showMessageDialog(null, "Cannot Continue! Error while writing the String to execute the HSHFitter");
                return ;
            }

            java.lang.Process p = null;
            /*
            if(this.FITTER_ABSOLUTE_PATH.toString().contains(" ")){
                String[] cmdLine = new String[6];
                cmdLine[0] = this.FITTER_ABSOLUTE_PATH.toString();
                String[] aux = this.COMMAND_LINE_ARGUMENTS.toString().split(" ");
                cmdLine[1] = aux[0]; //-RGB ou -LRGB
                cmdLine[2] = aux[1];
                cmdLine[3] = aux[2];//+ " " + aux[2]; // -i path_to_Lp
                cmdLine[4] = aux[3];// + " " + aux[4]; //-o path_to_output
                cmdLine[5] = aux[4];


                this.textArea.setText(this.textArea.getText() + "\nExecuting : "+ cmdLine[0] + " " + cmdLine[1] + " " +
                        cmdLine[2] + " " + cmdLine[3] + " " + cmdLine[4] + " " + cmdLine[5]);
                System.out.println("Exec : " + cmdLine[0] + " " + cmdLine[1] + " " +
                        cmdLine[2] + " " + cmdLine[3] + " " + cmdLine[4] + " " + cmdLine[5]);
                p = Runtime.getRuntime().exec(cmdLine);

            }else*/
            {
                System.out.println(this.COMMAND_LINE_ARGUMENTS.toString());

                this.textArea.setText(this.textArea.getText() + "\nExecuting : "+ this.COMMAND_LINE_ARGUMENTS.toString());
                p = Runtime.getRuntime().exec(this.argsList);
                //p = Runtime.getRuntime().exec(this.COMMAND_LINE_ARGUMENTS.toString());

            }

            BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
            //BufferedReader br2 = new BufferedReader(new InputStreamReader(p.getErrorStream()));
            
            String line;
            boolean erro = false;
            int auxHeight;

            if(cropUsed){
                if(toResize){
                    auxHeight = this.HEIGHT;
                }else{
                    auxHeight = this.cropHeight;
                }
            }else auxHeight = this.HEIGHT;


            
            while ((line = br.readLine()) != null) {

                System.out.println("Output | "+line);
                if(line.contains("Processing row: ")) {

                    this.fitterOutput.append("Processing row: ");
                    for(int x = 1; x < auxHeight; x++){
                        this.textArea.setText(this.fitterOutput.toString() + x);

                    }
                    this.fitterOutput.append(auxHeight).append("\n");
                    
                }else if(line.contains("Error")){
                    erro = true;
                    
                }else{
                    this.fitterOutput.append(line).append("\n");
                }
                
                this.textArea.setText(this.fitterOutput.toString());
            }

            int exitValue = p.waitFor();

            JFrame parent = new JFrame();
			
			int return_value = System.getProperty("os.name").toLowerCase().contains("win") ? 1 : 0;

            XMLHandler xml = null;
            try{
                xml = new XMLHandler(this.xmlPath.toString());
                xml.loadXML();
                //XMLPluginParser xmlaux = new XMLPluginParser("Plugins/PluginPTMfitter.xml");
                //xmlaux.setFitterPath(this.textHSHfitterLocation.getText());
                Event ev = new Event();
                ev.setLevel(Level.WARNING.toString());
                ev.setText("Saved HSHfitter Path : " + this.FITTER_ABSOLUTE_PATH);
                xml.registEvent(ev);
                
            }catch(Exception e){
                Event ev = new Event();
                ev.setLevel(Level.SEVERE.toString());
                ev.setText(e.getMessage());
                xml.registEvent(ev);


            }

            // Debuuuuug
            System.out.println("Debug\nexit="+exitValue+"\nreturn="+return_value+"\nerro="+erro);

            //if((exitValue == return_value)&&(!erro)){
            if ((exitValue == 0)&&(!erro)){
                JOptionPane.showMessageDialog(parent, "Fitting Completed");
                Event ev = new Event();
                ev.setLevel(Level.WARNING.toString());
                ev.setText("Fitter return ok!HSH was generated successfully");
                xml.registEvent(ev);
            }else{
                JOptionPane.showMessageDialog(parent, "Unknown Error Detected!");
                Event ev = new Event();
                ev.setLevel(Level.WARNING.toString());
                ev.setText("Fitter returned an error ! Error : " + exitValue);
                xml.registEvent(ev);
            }

            this.buttonExecute.setEnabled(true);

            try{
                xml.writeXML();
                XMLPluginParser xmlaux = new XMLPluginParser("Plugins/PluginHSHfitter.xml");
                xmlaux.setFitterPath(this.FITTER_ABSOLUTE_PATH.toString());

            }catch(Exception e){
                e.printStackTrace();
            }

        } catch (Exception ex) {
            //Logger.getLogger(FitterThread.class.getName()).log(Level.SEVERE, null, ex);
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "Error while trying to execute HSHFitter\nError dump : " + ex.getMessage());
            this.buttonExecute.setEnabled(true);
            ex.printStackTrace();

        }
        this.buttonExecute.setEnabled(true);
    }

}
